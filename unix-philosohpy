				The Unix Philosophy

I.    	Rule of Modularity: Write simple parts connected by clean interfaces.

II.    	Rule of Clarity: Clarity is better than cleverness.

III.    Rule of Composition: Design programs to be connected to other programs.

IV.    	Rule of Separation: Separate policy from mechanism; separate interfaces from engines.

V.    	Rule of Simplicity: Design for simplicity; add complexity only where you must.

VI.    	Rule of Parsimony: Write a big program only when it is clear by demonstration that nothing else will do.

VII.    Rule of Transparency: Design for visibility to make inspection and debugging easier.

VIII.   Rule of Robustness: Robustness is the child of transparency and simplicity.

IX.    	Rule of Representation: Fold knowledge into data so program logic can be stupid and robust.

X.    	Rule of Least Surprise: In interface design, always do the least surprising thing.

XI.    	Rule of Silence: When a program has nothing surprising to say, it should say nothing.

XII.   	Rule of Repair: When you must fail, fail noisily and as soon as possible.

XIII.   Rule of Economy: Programmer time is expensive; conserve it in preference to machine time.

XIV.   	Rule of Generation: Avoid hand-hacking; write programs to write programs when you can.

XV.    	Rule of Optimization: Prototype before polishing. Get it working before you optimize it.

XVI.   	Rule of Diversity: Distrust all claims for one true way.

XVII.   Rule of Extensibility: Design for the future, because it will be here sooner than you think.
